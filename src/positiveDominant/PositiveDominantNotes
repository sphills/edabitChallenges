ACTIVITY NOTES FOR:

https://edabit.com/challenge/zi3zKpBLYHqtmSf5m

PROMPT:

n array is positive dominant if it contains strictly more unique positive values than unique negative values. Write a function that returns true if an array is positive dominant, false, otherwise.

	Examples:
		isPositiveDominant([1, 1, 1, 1, -3, -4]) ➞ false
		// There is only 1 unique positive value (1).
		// There are 2 unique negative values (-3, -4).
		
		isPositiveDominant([5, 99, 832, -3, -4]) ➞ true
		
		isPositiveDominant([5, 0]) ➞ true
		
		isPositiveDominant([0, -4, -1]) ➞ false
		
	Notes:
		0 counts as neither a positive nor a negative value.

ELEMENTS:

1) public static boolean isPositiveDominant(int[] inputArray)
2) Array clone
3) Nested for loop

MY THOUGHTS:

My first thought is to clone the incoming array, use a nested for loop to compare all of the elements in the loop against each other,
whether or not they are positive, and sum the number of unique values. Then, return int sumUniquePositive > sumUniqueNegative.

	UPDATE:
		I got through the below prototype code before I realized I wasn't sure how to make it count the number of values,
		to include when j == 0. This commit is for accountability, but I have an idea.

PROTOTYPE:

public static boolean isPositiveDominant(int[] inputArray) {

	int sumUniquePositive = 0;
	int sumUniqueNegative = 0;
	int[] clonedArray = inputArray.clone();
	
	for (int i = 0; i < inputArray.length; i++) {
		for (int j = 0; j < clonedArray.length; j++) {
			if (j == i){
			} else {
				if (clonedArray[j] != inputArray[j]) {
					if (clonedArray[j] > 0) {
						sumUniquePositive++;
					} else if (clonedArray[j] < 0) {
						sumUniqueNegative++;
					}
				}
			}
		} 
	}
}

POST ACTIVITY THOUGHTS:


