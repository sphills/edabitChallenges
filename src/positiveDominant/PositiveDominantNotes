ACTIVITY NOTES FOR:

https://edabit.com/challenge/zi3zKpBLYHqtmSf5m

PROMPT:

n array is positive dominant if it contains strictly more unique positive values than unique negative values. Write a function that returns true if an array is positive dominant, false, otherwise.

	Examples:
		isPositiveDominant([1, 1, 1, 1, -3, -4]) ➞ false
		// There is only 1 unique positive value (1).
		// There are 2 unique negative values (-3, -4).
		
		isPositiveDominant([5, 99, 832, -3, -4]) ➞ true
		
		isPositiveDominant([5, 0]) ➞ true
		
		isPositiveDominant([0, -4, -1]) ➞ false
		
	Notes:
		0 counts as neither a positive nor a negative value.

ELEMENTS:

1) public static boolean isPositiveDominant(int[] inputArray)
2) Array clone
3) Nested for loop

MY THOUGHTS:

My first thought is to clone the incoming array, use a nested for loop to compare all of the elements in the loop against each other,
whether or not they are positive, and sum the number of unique values. Then, return int sumUniquePositive > sumUniqueNegative.

	UPDATE:
		I got through the below prototype code before I realized I wasn't sure how to make it count the number of values,
		to include when j == 0. This commit is for accountability, but I have an idea.

PROTOTYPE:

public static boolean isPositiveDominant(int[] inputArray) {

	int positiveArraySize = 0;
	int negativeArraySize = 0;
	
	for (int h = 0; h < inputArray.length; h++) {
		if (inputArray[h] > 0) {
			positiveArraySize++;
		} else if (inputArray[h] < 0) {
			negativeArraySize++;
		}
	}
	
	int[] positiveArray = new int[positiveArraySize];
	int[] negativeArray = new int[negativeArraySize];
	
	// First, we check to see how many positive or negative numbers there are so we can generate an int[] of appropriate size
	for (int i = 0; i < inputArray.length; i++) {
		if (inputArray[i] > 0) {
			for (int j = 0; j < positiveArray.length; j++) {
				if (positiveArray[j] == 0) {
					positiveArray[j] = inputArray[i];
					break;
				}
			}
		} else if (inputArray[i] < 0) {
			for (int k = 0; k < negativeArray.length; k++) {
				if (negativeArray[k] == 0) {
					negativeArray[k] = inputArray[i];
					break;
				}
			}
		} // We don't want to do anything with 0, so there's no test case for it
	}
	
	// Then, we set up these variables for the boolean return...
	int sumUniquePositive = 0;
	int sumUniqueNegative = 0;
	
	// And this loop checks for the amount of unique positive integers...
	for (int l = 0; l < positiveArray.length; l++) {
		for (int m = 1; m < positiveArray.length; m++) {
			if (positiveArray[m] != positiveArray[l]) {
				sumUniquePositive++;
			}
		}
	}
	
	// And this loop checks for the amount of unique negative integers...
	for (int n = 0; n < negativeArray.length; n++) {
		for (int p = 0; p < negativeArray.length; p++) {
			if (negativeArray[p] != negativeArray[n]) {
				sumUniqueNegative++;
			}
		}
	}
	
	return sumUniquePositive > sumUniqueNegative;
}

POST ACTIVITY THOUGHTS:


